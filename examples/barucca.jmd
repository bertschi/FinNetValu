
```julia
using Pkg
Pkg.activate("/home/bertschi/GitRepos/FinNetValu/")
```

```julia
using FinNetValu
using Distributions
using LinearAlgebra
using SparseArrays
using ForwardDiff
using Plots
using DataFrames
```

## Examples from Barucca et al. (2016)

Here we replicate some figures from the paper

Paolo Barucca, Marco Bardoscia, Fabio Caccioli, Marco D‚ÄôErrico, Gabriele Visentin, Stefano Battiston and Guido Caldarelli, *Network Valuation in Financial Systems*, arXiv:1606.05164v2, 2016.

First, we redefine the LinearDebtRankModel such that the bookequity is externally given ... hoping that this allows to replicate the figures from the paper.

```julia
function LinearDebtRankModel(L·µâ::AbstractVector, L::AbstractMatrix, bookequity::AbstractVector)
    function val(net, e, a)
        transpose(FinNetValu.valueLR.(e, bookequity))
    end
    NEVAModel("Linear Debt Rank",
              L·µâ,
              L,
              constantly(one(eltype(L))),
              val)
end
```

To reproduce figure 1, we use the simplest possible setup. I.e. we define the corresponding models with a single firm and run their valuations functions across a range of equities.

```julia
EN = EisenbergNoeModel([0.0], 2 .* ones(1,1))
Furfine = FurfineModel([0.0], 2 .* ones(1,1), 0)
LinearDR = LinearDebtRankModel([0.0], 2 * ones(1,1), [2.5])
ExAnteEN = ExAnteEN_BS_Model([0.0], 2 .* ones(1,1), 1.0, BlackScholesParams(0.0, 1.0, 0.1))
```

```julia
equities = range(-3, length = 251, stop = 3)
ùïç_EN = [EN.ùïç(EN, e, nothing)[1] for e in equities]
ùïç_Furfine = [Furfine.ùïç(Furfine, e, nothing)[1] for e in equities]
ùïç_LinearDR = [LinearDR.ùïç(LinearDR, e, [0.0])[1] for e in equities] # Note: A should be ignored here!
ùïç_ExAnteEN = [ExAnteEN.ùïç(ExAnteEN, e, [0.0])[1] for e in equities]

plt = plot(equities, ùïç_EN, label = "EN",
           xlabel = "equity of the borrower", ylabel = "interbank valuation function")
plot!(plt, equities, ùïç_Furfine, label = "Furfine")
plot!(plt, equities, ùïç_LinearDR, label = "Linear DR")
plot!(plt, equities, ùïç_ExAnteEN, label = "Ex-ante EN")
```

Note that the valuation formula $\mathbb{V}_{ij} = \frac{E_j^+}{M_j}$ for the linear debt rank model is actually not correct in the paper as it can exceed one. In practice, this should not be a problem as a firms equity value $E_j$ never exceeds its book equity $M_j$. Here, values are clipped between 0 and 1 as in the accompanying code at https://github.com/marcobardoscia/neva

Next, we replicate the left panel of figure 2.

```julia
# External liabilities
L·µâ = [9., 4., 2.]
# Cross-holding matrix
A = [0 0.5 0;
     0 0 0.5;
     0.5 0 0]
# External asset values
A·µâ = [10., 5., 3.]

models = [EisenbergNoeModel(L·µâ, A'),
          FurfineModel(L·µâ, A', 0.0),
          LinearDebtRankModel(L·µâ, A', fill(1., 3)),
          ExAnteEN_BS_Model(L·µâ, A', 1.0, BlackScholesParams(0.0, 1.0, 0.1))]
```

Each model is then shocked by decreasing the external asset value by a factor $\alpha$ and compute the impact on the equity value as in the paper, i.e.
$$
    \frac{\sum_i {\Delta}E_i - {\Delta}A^e_i}{\sum_{ij} A_{ij}}
$$
where ${\Delta}A^e = \alpha A^e$.

```julia
function runshock(model, A·µâ, Œ±)
    E‚ÇÄ = fixvalue(model, A·µâ)
    ŒîA·µâ = Œ± .* A·µâ
    ŒîE  = E‚ÇÄ .- fixvalue(model, A·µâ .- ŒîA·µâ)
    sum(ŒîE .- ŒîA·µâ) / sum(model.A)
end
```

```julia
Œ±s = range(0, length = 101, stop = 0.6)
shocks = collect(runshock(model, A·µâ, Œ±)
                 for Œ± in Œ±s,
                     model in models);
```

```julia
plot(Œ±s, shocks, label = ["EN", "Furfine", "Linear DR", "NEVA"],
     xlabel = "shock", ylabel = "network contribution (relative to max)")
```

Now, the linear debt rank model looks right (we should refactor the models though to correctly implement this model within the library), but the ex-ante version of the model appears shifted. In order to investigate this issue in more detail, we reproduce some other figures using that model.

We start with the right panel of figure 2 which compares the valuation adjustment for the book equity with the corresponding one taking into account network effects:

```julia
modelNEVA = FinNetValu.ExAnteEN_BS_Model(L·µâ, A', 1.0, BlackScholesParams(0.0, 1.0, 0.1))

Œ±s = range(0, length = 101, stop = 0.6)
df = DataFrame(Œ± = Vector{Float64}(),
               bankA = Vector{Float64}(),
               bankB = Vector{Float64}(),
               bankC = Vector{Float64}())
for Œ± in Œ±s
    a = (1 - Œ±) .* A·µâ
    m = bookequity(modelNEVA, a)
    e = fixvalue(modelNEVA, a)
    val = modelNEVA.ùïç(modelNEVA, m, a) .- modelNEVA.ùïç(modelNEVA, e, a)
    push!(df, vcat(Œ±, val'))
end
```

```julia
plot(df.Œ±, df.bankA)
```

```julia
plot(df.Œ±, df.bankB)
```

```julia
plot(df.Œ±, df.bankC)
```

Finally, we replicate all figures from the appendix.

```julia
function fig_limit(A·µâ, A)
    L·µâ = fill(0.0, 3)
    modelEN = FinNetValu.EisenbergNoeModel(L·µâ, A')
    println(fixvalue(modelEN, A·µâ))

    œÑs = 10 .^ (-1:0.05:1)
    df = DataFrame(œÑ = Vector{Float64}(),
               bankA = Vector{Float64}(),
               bankB = Vector{Float64}(),
               bankC = Vector{Float64}())
    
    for œÑ in œÑs
        modelExAnteEN = FinNetValu.ExAnteEN_BS_Model(L·µâ, A',
                                                     1.0,
                                                     BlackScholesParams(0.0, œÑ, 10.))
        e = fixvalue(modelExAnteEN, A·µâ)
        push!(df, vcat(œÑ, e))
    end
    df
end
```

```julia
df_fig3 = fig_limit([1, 1, 1], [0 1.2 0; 0 0 1.2; 0 0 0])

plot(log.(df_fig3.œÑ), df_fig3.bankA)
```

```julia
plot(log.(df_fig3.œÑ), df_fig3.bankB)
```

```julia
plot(log.(df_fig3.œÑ), df_fig3.bankC)
```

    
