
```julia
using Pkg
Pkg.activate(joinpath(homedir(), "GitRepos/FinNetValu/"))
```

```julia
using FinNetValu
using Distributions
using LinearAlgebra
using SparseArrays
using ForwardDiff
using Plots
using DataFrames
```

## Examples from Barucca et al. (2016)

Here we replicate some figures from the paper

Paolo Barucca, Marco Bardoscia, Fabio Caccioli, Marco D‚ÄôErrico, Gabriele Visentin, Stefano Battiston and Guido Caldarelli, *Network Valuation in Financial Systems*, arXiv:1606.05164v2, 2016.

To reproduce figure 1, we use the simplest possible setup. I.e. we
define the corresponding models with a single firm and run their
valuations functions across a range of equities.

```julia
EN = EisenbergNoeModel([0.0], 2 .* ones(1,1))
Furfine = FurfineModel([0.0], 2 .* ones(1,1), 0)
LinearDR = LinearDebtRankModel([0.0], 2 * ones(1,1), [2.5])
ExAnteEN = ExAnteEN_BS_Model([0.0], 2 .* ones(1,1), 1.0, BlackScholesParams(0.0, 1.0, 1.0))
```

```julia
equities = range(-3, length = 251, stop = 3)
ùïç_EN = [EN.ùïç(EN, e, nothing)[1] for e in equities]
ùïç_Furfine = [Furfine.ùïç(Furfine, e, nothing)[1] for e in equities]
ùïç_LinearDR = [LinearDR.ùïç(LinearDR, e, nothing)[1] for e in equities]
ùïç_ExAnteEN = [ExAnteEN.ùïç(ExAnteEN, e, [1.0])[1] for e in equities]

plt = plot(equities, ùïç_EN, label = "EN",
           xlabel = "equity of the borrower", ylabel = "interbank valuation function")
plot!(plt, equities, ùïç_Furfine, label = "Furfine")
plot!(plt, equities, ùïç_LinearDR, label = "Linear DR")
plot!(plt, equities, ùïç_ExAnteEN, label = "Ex-ante EN")
```

Note that the valuation formula $\mathbb{V}_{ij} = \frac{E_j^+}{M_j}$
for the linear debt rank model is actually not correct in the paper as
it can exceed one. In practice, this should not be a problem as a
firms equity value $E_j$ never exceeds its book equity $M_j$. Here,
values are clipped between 0 and 1 as in the accompanying code at
https://github.com/marcobardoscia/neva

Next, we replicate the left panel of figure 2.

```julia
# External liabilities
L·µâ = [9., 4., 2.]
# Cross-holding matrix
A = [0 0.5 0;
     0 0 0.5;
     0.5 0 0]
# External asset values
A·µâ = [10., 5., 3.]

models = [EisenbergNoeModel(L·µâ, A'),
          FurfineModel(L·µâ, A', 0.0),
          LinearDebtRankModel(L·µâ, A', fill(1., 3)),
          ExAnteEN_BS_Model(L·µâ, A', 1.0, BlackScholesParams(0.0, 1.0, 0.1))]
```

Each model is then shocked by decreasing the external asset value by a
factor $\alpha$ and compute the impact on the equity value as in the
paper, i.e.        
$$
    \frac{\sum_i {\Delta}E_i - {\Delta}A^e_i}{\sum_{ij} A_{ij}}
$$
where ${\Delta}A^e = \alpha A^e$.

```julia
const solver = PicardIteration(1e-12, 1e-12)
function runshock(model, A·µâ, Œ±)
    E‚ÇÄ = fixvalue(solver, model, A·µâ)
    ŒîA·µâ = Œ± .* A·µâ
    ŒîE  = E‚ÇÄ .- fixvalue(solver, model, A·µâ .- ŒîA·µâ)
    sum(ŒîE .- ŒîA·µâ) / sum(model.A)
end
```

```julia
Œ±s = range(0, length = 101, stop = 0.6)
shocks = collect(runshock(model, A·µâ, Œ±)
                 for Œ± in Œ±s,
                     model in models);
```

```julia
plot(Œ±s, shocks, label = ["EN", "Furfine", "Linear DR", "NEVA"],
     xlabel = "shock", ylabel = "network contribution (relative to max)")
```

The linear debt rank model with externally fixed book equity looks
right, but the ex-ante version of the model appears shifted. In order
to investigate this issue in more detail, we reproduce some other
figures using that model.

We start with the right panel of figure 2 which compares the valuation
adjustment for the book equity with the corresponding one taking into
account network effects:

```julia
modelNEVA = FinNetValu.ExAnteEN_BS_Model(L·µâ, A', 1.0, BlackScholesParams(0.0, 1.0, 0.1))

function bookequity(net::NEVAModel, a::AbstractVector)
    lÃÑ = nominaldebt(net)
    a .+ net.A * lÃÑ .- lÃÑ
end 

Œ±s = range(0, length = 101, stop = 0.6)
df = DataFrame(Œ± = Vector{Float64}(),
               bankA = Vector{Float64}(),
               bankB = Vector{Float64}(),
               bankC = Vector{Float64}())
for Œ± in Œ±s
    a = (1 - Œ±) .* A·µâ
    m = bookequity(modelNEVA, a)
    e = fixvalue(solver, modelNEVA, a)
    val = modelNEVA.ùïç(modelNEVA, m, a) .- modelNEVA.ùïç(modelNEVA, e, a)
    push!(df, vcat(Œ±, val'))
end
```

```julia
plot(df.Œ±, df.bankA)
```

```julia
plot(df.Œ±, df.bankB)
```

```julia
plot(df.Œ±, df.bankC)
```

Finally, we replicate all figures from the appendix.

```julia
function fig_limit(A·µâ, A)
    L·µâ = fill(0.0, 3)
    modelEN = FinNetValu.EisenbergNoeModel(L·µâ, A')
    println(fixvalue(solver, modelEN, A·µâ))

    œÑs = 10 .^ (-2:0.05:2)
    df = DataFrame(œÑ = Vector{Float64}(),
               bankA = Vector{Float64}(),
               bankB = Vector{Float64}(),
               bankC = Vector{Float64}())
    
    for œÑ in œÑs
        modelExAnteEN = FinNetValu.ExAnteEN_BS_Model(L·µâ, A',
                                                     1.0,
                                                     BlackScholesParams(0.0, œÑ, 1.0))
        e = fixvalue(solver, modelExAnteEN, A·µâ)
        push!(df, vcat(œÑ, e))
    end
    df
end
```

```julia
df_fig3 = fig_limit([1, 1, 1], [0 1.2 0; 0 0 1.2; 0 0 0])

plot(log10.(df_fig3.œÑ), df_fig3.bankA)
```

```julia
plot(log10.(df_fig3.œÑ), df_fig3.bankB)
```

```julia
plot(log10.(df_fig3.œÑ), df_fig3.bankC)
```

```julia
df_fig4 = fig_limit([1, 0.1, 1], [0 1 1; 0 0 0; 0 0 0])

plot(log10.(df_fig4.œÑ), df_fig4.bankA)
```

```julia
plot(log10.(df_fig4.œÑ), df_fig4.bankB)
```

```julia
plot(log10.(df_fig4.œÑ), df_fig4.bankC)
```

```julia
df_fig5 = fig_limit([1, 1, 1], [0 1.1 0; 0 0 1.2; 1.5 0 0])

plot(log10.(df_fig5.œÑ), df_fig5.bankA)
```

```julia
plot(log10.(df_fig5.œÑ), df_fig5.bankB)
```

```julia
plot(log10.(df_fig5.œÑ), df_fig5.bankC)
```

All figures appear qualitatively correct, but the scale on the
maturity axis is larger! Maybe a different $\sigma$1 might work as
this is not given in the paper.
